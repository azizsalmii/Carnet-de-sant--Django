from collections.abc import Callable, Sequence
from typing import (
<<<<<<< HEAD
    Any,
    Concatenate,
    ParamSpec,
    Protocol,
    SupportsIndex,
    TypeVar,
    overload,
=======
    TypeVar,
    Any,
    overload,
    SupportsIndex,
    Protocol,
    ParamSpec,
    Concatenate,
>>>>>>> Mental-Health
    type_check_only,
)

from typing_extensions import deprecated

import numpy as np
<<<<<<< HEAD
from numpy import (
    _CastingKind,
    complexfloating,
    floating,
    generic,
    integer,
    object_,
    signedinteger,
    ufunc,
    unsignedinteger,
)
=======
from numpy import _CastingKind, generic, integer, ufunc, unsignedinteger, signedinteger, floating, complexfloating, object_
>>>>>>> Mental-Health
from numpy._typing import (
    ArrayLike,
    DTypeLike,
    NDArray,
<<<<<<< HEAD
    _ArrayLike,
    _ArrayLikeBool_co,
    _ArrayLikeComplex_co,
    _ArrayLikeFloat_co,
    _ArrayLikeInt_co,
    _ArrayLikeObject_co,
    _ArrayLikeUInt_co,
    _ShapeLike,
=======
    _ShapeLike,
    _ArrayLike,
    _ArrayLikeBool_co,
    _ArrayLikeUInt_co,
    _ArrayLikeInt_co,
    _ArrayLikeFloat_co,
    _ArrayLikeComplex_co,
    _ArrayLikeObject_co,
>>>>>>> Mental-Health
)

__all__ = [
    "column_stack",
    "row_stack",
    "dstack",
    "array_split",
    "split",
    "hsplit",
    "vsplit",
    "dsplit",
    "apply_over_axes",
    "expand_dims",
    "apply_along_axis",
    "kron",
    "tile",
    "take_along_axis",
    "put_along_axis",
]

_P = ParamSpec("_P")
<<<<<<< HEAD
_ScalarT = TypeVar("_ScalarT", bound=generic)
=======
_SCT = TypeVar("_SCT", bound=generic)
>>>>>>> Mental-Health

# Signature of `__array_wrap__`
@type_check_only
class _ArrayWrap(Protocol):
    def __call__(
        self,
        array: NDArray[Any],
<<<<<<< HEAD
        context: tuple[ufunc, tuple[Any, ...], int] | None = ...,
=======
        context: None | tuple[ufunc, tuple[Any, ...], int] = ...,
>>>>>>> Mental-Health
        return_scalar: bool = ...,
        /,
    ) -> Any: ...

@type_check_only
class _SupportsArrayWrap(Protocol):
    @property
    def __array_wrap__(self) -> _ArrayWrap: ...

###

def take_along_axis(
<<<<<<< HEAD
    arr: _ScalarT | NDArray[_ScalarT],
    indices: NDArray[integer],
    axis: int | None = ...,
) -> NDArray[_ScalarT]: ...

def put_along_axis(
    arr: NDArray[_ScalarT],
    indices: NDArray[integer],
    values: ArrayLike,
    axis: int | None,
=======
    arr: _SCT | NDArray[_SCT],
    indices: NDArray[integer[Any]],
    axis: None | int,
) -> NDArray[_SCT]: ...

def put_along_axis(
    arr: NDArray[_SCT],
    indices: NDArray[integer[Any]],
    values: ArrayLike,
    axis: None | int,
>>>>>>> Mental-Health
) -> None: ...

@overload
def apply_along_axis(
<<<<<<< HEAD
    func1d: Callable[Concatenate[NDArray[Any], _P], _ArrayLike[_ScalarT]],
=======
    func1d: Callable[Concatenate[NDArray[Any], _P], _ArrayLike[_SCT]],
>>>>>>> Mental-Health
    axis: SupportsIndex,
    arr: ArrayLike,
    *args: _P.args,
    **kwargs: _P.kwargs,
<<<<<<< HEAD
) -> NDArray[_ScalarT]: ...
=======
) -> NDArray[_SCT]: ...
>>>>>>> Mental-Health
@overload
def apply_along_axis(
    func1d: Callable[Concatenate[NDArray[Any], _P], Any],
    axis: SupportsIndex,
    arr: ArrayLike,
    *args: _P.args,
    **kwargs: _P.kwargs,
) -> NDArray[Any]: ...

def apply_over_axes(
<<<<<<< HEAD
    func: Callable[[NDArray[Any], int], NDArray[_ScalarT]],
    a: ArrayLike,
    axes: int | Sequence[int],
) -> NDArray[_ScalarT]: ...

@overload
def expand_dims(
    a: _ArrayLike[_ScalarT],
    axis: _ShapeLike,
) -> NDArray[_ScalarT]: ...
=======
    func: Callable[[NDArray[Any], int], NDArray[_SCT]],
    a: ArrayLike,
    axes: int | Sequence[int],
) -> NDArray[_SCT]: ...

@overload
def expand_dims(
    a: _ArrayLike[_SCT],
    axis: _ShapeLike,
) -> NDArray[_SCT]: ...
>>>>>>> Mental-Health
@overload
def expand_dims(
    a: ArrayLike,
    axis: _ShapeLike,
) -> NDArray[Any]: ...

# Deprecated in NumPy 2.0, 2023-08-18
@deprecated("`row_stack` alias is deprecated. Use `np.vstack` directly.")
def row_stack(
    tup: Sequence[ArrayLike],
    *,
    dtype: DTypeLike | None = None,
    casting: _CastingKind = "same_kind",
) -> NDArray[Any]: ...

#
@overload
<<<<<<< HEAD
def column_stack(tup: Sequence[_ArrayLike[_ScalarT]]) -> NDArray[_ScalarT]: ...
=======
def column_stack(tup: Sequence[_ArrayLike[_SCT]]) -> NDArray[_SCT]: ...
>>>>>>> Mental-Health
@overload
def column_stack(tup: Sequence[ArrayLike]) -> NDArray[Any]: ...

@overload
<<<<<<< HEAD
def dstack(tup: Sequence[_ArrayLike[_ScalarT]]) -> NDArray[_ScalarT]: ...
=======
def dstack(tup: Sequence[_ArrayLike[_SCT]]) -> NDArray[_SCT]: ...
>>>>>>> Mental-Health
@overload
def dstack(tup: Sequence[ArrayLike]) -> NDArray[Any]: ...

@overload
def array_split(
<<<<<<< HEAD
    ary: _ArrayLike[_ScalarT],
    indices_or_sections: _ShapeLike,
    axis: SupportsIndex = ...,
) -> list[NDArray[_ScalarT]]: ...
=======
    ary: _ArrayLike[_SCT],
    indices_or_sections: _ShapeLike,
    axis: SupportsIndex = ...,
) -> list[NDArray[_SCT]]: ...
>>>>>>> Mental-Health
@overload
def array_split(
    ary: ArrayLike,
    indices_or_sections: _ShapeLike,
    axis: SupportsIndex = ...,
) -> list[NDArray[Any]]: ...

@overload
def split(
<<<<<<< HEAD
    ary: _ArrayLike[_ScalarT],
    indices_or_sections: _ShapeLike,
    axis: SupportsIndex = ...,
) -> list[NDArray[_ScalarT]]: ...
=======
    ary: _ArrayLike[_SCT],
    indices_or_sections: _ShapeLike,
    axis: SupportsIndex = ...,
) -> list[NDArray[_SCT]]: ...
>>>>>>> Mental-Health
@overload
def split(
    ary: ArrayLike,
    indices_or_sections: _ShapeLike,
    axis: SupportsIndex = ...,
) -> list[NDArray[Any]]: ...

@overload
def hsplit(
<<<<<<< HEAD
    ary: _ArrayLike[_ScalarT],
    indices_or_sections: _ShapeLike,
) -> list[NDArray[_ScalarT]]: ...
=======
    ary: _ArrayLike[_SCT],
    indices_or_sections: _ShapeLike,
) -> list[NDArray[_SCT]]: ...
>>>>>>> Mental-Health
@overload
def hsplit(
    ary: ArrayLike,
    indices_or_sections: _ShapeLike,
) -> list[NDArray[Any]]: ...

@overload
def vsplit(
<<<<<<< HEAD
    ary: _ArrayLike[_ScalarT],
    indices_or_sections: _ShapeLike,
) -> list[NDArray[_ScalarT]]: ...
=======
    ary: _ArrayLike[_SCT],
    indices_or_sections: _ShapeLike,
) -> list[NDArray[_SCT]]: ...
>>>>>>> Mental-Health
@overload
def vsplit(
    ary: ArrayLike,
    indices_or_sections: _ShapeLike,
) -> list[NDArray[Any]]: ...

@overload
def dsplit(
<<<<<<< HEAD
    ary: _ArrayLike[_ScalarT],
    indices_or_sections: _ShapeLike,
) -> list[NDArray[_ScalarT]]: ...
=======
    ary: _ArrayLike[_SCT],
    indices_or_sections: _ShapeLike,
) -> list[NDArray[_SCT]]: ...
>>>>>>> Mental-Health
@overload
def dsplit(
    ary: ArrayLike,
    indices_or_sections: _ShapeLike,
) -> list[NDArray[Any]]: ...

@overload
def get_array_wrap(*args: _SupportsArrayWrap) -> _ArrayWrap: ...
@overload
<<<<<<< HEAD
def get_array_wrap(*args: object) -> _ArrayWrap | None: ...
=======
def get_array_wrap(*args: object) -> None | _ArrayWrap: ...
>>>>>>> Mental-Health

@overload
def kron(a: _ArrayLikeBool_co, b: _ArrayLikeBool_co) -> NDArray[np.bool]: ...  # type: ignore[misc]
@overload
<<<<<<< HEAD
def kron(a: _ArrayLikeUInt_co, b: _ArrayLikeUInt_co) -> NDArray[unsignedinteger]: ...  # type: ignore[misc]
@overload
def kron(a: _ArrayLikeInt_co, b: _ArrayLikeInt_co) -> NDArray[signedinteger]: ...  # type: ignore[misc]
@overload
def kron(a: _ArrayLikeFloat_co, b: _ArrayLikeFloat_co) -> NDArray[floating]: ...  # type: ignore[misc]
@overload
def kron(a: _ArrayLikeComplex_co, b: _ArrayLikeComplex_co) -> NDArray[complexfloating]: ...
=======
def kron(a: _ArrayLikeUInt_co, b: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...  # type: ignore[misc]
@overload
def kron(a: _ArrayLikeInt_co, b: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...  # type: ignore[misc]
@overload
def kron(a: _ArrayLikeFloat_co, b: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...  # type: ignore[misc]
@overload
def kron(a: _ArrayLikeComplex_co, b: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
>>>>>>> Mental-Health
@overload
def kron(a: _ArrayLikeObject_co, b: Any) -> NDArray[object_]: ...
@overload
def kron(a: Any, b: _ArrayLikeObject_co) -> NDArray[object_]: ...

@overload
def tile(
<<<<<<< HEAD
    A: _ArrayLike[_ScalarT],
    reps: int | Sequence[int],
) -> NDArray[_ScalarT]: ...
=======
    A: _ArrayLike[_SCT],
    reps: int | Sequence[int],
) -> NDArray[_SCT]: ...
>>>>>>> Mental-Health
@overload
def tile(
    A: ArrayLike,
    reps: int | Sequence[int],
) -> NDArray[Any]: ...
